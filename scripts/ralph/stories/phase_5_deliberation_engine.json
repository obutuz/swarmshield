{
  "branchName": "ralph/phase-5-deliberation",
  "description": "Multi-agent Opus 4.6 deliberation engine with full GhostProtocol lifecycle. Spawns parallel AI agents to analyze flagged events, facilitates structured debate, reaches consensus verdicts, then executes GhostProtocol wipe (agents vanish, data destroyed, only verdict survives).",
  "phase": 5,
  "phaseName": "Deliberation Engine + GhostProtocol",
  "crossPhaseLinks": {
    "phase_1_auth_foundation": "Audit entries created for all deliberation actions. Workspace scoping.",
    "phase_2_core_schemas": "Uses AgentDefinition, PromptTemplate, Workflow, WorkflowStep, ConsensusPolicy, AnalysisSession, AgentInstance, DeliberationMessage, Verdict, GhostProtocolConfig schemas.",
    "phase_3_policy_engine": "Flagged events from PolicyEngine trigger deliberation.",
    "phase_4_api_gateway": "Gateway publishes {:trigger_deliberation, event, workflow} via PubSub.",
    "phase_6_dashboard_liveviews": "DeliberationShowLive displays real-time debate via PubSub. GhostProtocolLive shows active ephemeral sessions.",
    "phase_7_admin_liveviews": "Admin manages workflows, agent definitions, prompt templates, consensus policies, ghost protocol configs."
  },
  "securityRules": {
    "prompt_injection": "LLM calls use Anthropic structured message format - system prompt in system parameter, user event content in user role. NEVER embed raw event content in system prompt strings.",
    "workspace_scoping": "All context functions enforce workspace_id. Session GenServer verifies event and workflow belong to same workspace.",
    "no_code_execution": "PromptRenderer uses safe String.replace/3 only. NEVER Code.eval_string, EEx.eval_string, or dynamic code generation.",
    "input_validation": "Vote values validated against explicit allowlist. LLM responses parsed safely with error handling. Template variables use literal substitution only.",
    "ssrf_prevention": "LLM client ONLY calls configured Anthropic API endpoint from runtime config. NEVER construct target URL from user input or database fields.",
    "audit_trail": "Session lifecycle, verdict creation, GhostProtocol wipe actions, and budget limit events all create audit_entry records.",
    "atom_safety": "Vote values and decision enums use String.to_existing_atom or explicit allowlists. NEVER create atoms from arbitrary user/LLM input.",
    "ghost_protocol_security": "Wipe engine reads config from database. crypto_shred uses :crypto.strong_rand_bytes to overwrite before NULL. Wipe fields validated against allowlist. Only verdict + audit survive."
  },
  "userStories": [
    {
      "id": "DELIB-001",
      "title": "Create Deliberation context",
      "description": "Deliberation context manages AnalysisSession, AgentInstance, DeliberationMessage, and Verdict CRUD. Provides the data layer for the deliberation engine.",
      "priority": 1,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Context at lib/swarmshield/deliberation.ex",
        "AnalysisSession CRUD: list_analysis_sessions/1 (by workspace_id, filterable by status/date, paginated, preload verdict), get_analysis_session!/1 (preload agent_instances, messages, verdict), create_analysis_session/1, update_analysis_session/2",
        "AgentInstance CRUD: list_agent_instances/1 (by session_id), get_agent_instance!/1, create_agent_instance/1, update_agent_instance/2",
        "DeliberationMessage: create_deliberation_message/1, list_messages_by_session/1 (ordered by round then inserted_at), list_messages_by_instance/1",
        "Verdict: create_verdict/1, get_verdict_by_session/1",
        "All list functions include preloads (no N+1)",
        "PubSub broadcast on session status changes: 'deliberations:workspace_id'",
        "Tests for all CRUD operations",
        "Edge case: list_analysis_sessions/1 with status filter returns only matching sessions",
        "Edge case: get_analysis_session!/1 raises Ecto.NoResultsError for missing ID",
        "Edge case: update_analysis_session/2 validates status transitions (no going backwards)",
        "Edge case: list_messages_by_session/1 returns messages ordered by round ASC, inserted_at ASC",
        "Edge case: get_verdict_by_session/1 returns nil for sessions without verdict",
        "Edge case: all preloads verified via Ecto.assoc_loaded?/1 in tests",
        "QUERY QUALITY: list_analysis_sessions/1 uses JOINs for verdict preload (not N+1 per-session query)",
        "QUERY QUALITY: get_analysis_session!/1 uses multi-level preload in single query: preload [agent_instances: :deliberation_messages, :verdict]",
        "QUERY QUALITY: list_analysis_sessions/1 uses database-level pagination with {results, total_count} tuple",
        "QUERY QUALITY: list_messages_by_session/1 uses single query with ORDER BY round, inserted_at (not post-load sort)",
        "QUERY QUALITY: No correlated subqueries in any context function - all aggregates use JOIN + GROUP BY",
        "QUERY QUALITY: Session token/cost totals computed via database SUM aggregate (not Enum.reduce on loaded instances)",
        "Minimum 20 test cases",
        "SECURITY: All query functions must enforce workspace_id as mandatory parameter - NEVER return cross-workspace sessions or verdicts",
        "SECURITY: Session lifecycle changes (started, completed, failed) must create audit_entry records",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-002",
      "title": "Create Agents context",
      "description": "Agents context manages AgentDefinition and PromptTemplate CRUD. These are the configuration entities that define how AI agents behave during deliberation.",
      "priority": 2,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Agent definitions and prompt templates are database-driven - ZERO hardcoded agent personas or prompts",
        "Context at lib/swarmshield/agents.ex",
        "AgentDefinition CRUD: list_agent_definitions/1 (by workspace_id, filterable), get_agent_definition!/1, create_agent_definition/1, update_agent_definition/2, delete_agent_definition/1, list_enabled_agent_definitions/1",
        "PromptTemplate CRUD: list_prompt_templates/1 (by workspace_id, filterable by category), get_prompt_template!/1, create_prompt_template/1, update_prompt_template/2, delete_prompt_template/1",
        "All list functions include preloads",
        "Tests for all CRUD operations",
        "Edge case: delete_agent_definition/1 with active workflow steps returns error (referential integrity)",
        "Edge case: list_enabled_agent_definitions/1 returns only enabled=true definitions",
        "Edge case: list_prompt_templates/1 filtered by category returns only matching templates",
        "Edge case: delete_prompt_template/1 that is referenced by workflow steps returns error",
        "QUERY QUALITY: All list functions use JOINs for preloads in single query (not N+1)",
        "QUERY QUALITY: list_enabled_agent_definitions/1 uses indexed WHERE on [:workspace_id, :enabled]",
        "QUERY QUALITY: delete checks (referential integrity) use EXISTS subquery, not loading all workflow_steps",
        "QUERY QUALITY: No correlated subqueries in any context function",
        "Minimum 12 test cases",
        "SECURITY: Changesets must NEVER cast [:workspace_id] from user input - set server-side from current_user's workspace",
        "SECURITY: All CRUD operations on agent definitions and prompt templates must create audit_entry records",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-003",
      "title": "Create Workflows context",
      "description": "Workflows context manages Workflow, WorkflowStep, and ConsensusPolicy CRUD. Provides pipeline configuration for the deliberation engine. Workflow now includes optional ghost_protocol_config_id for ephemeral sessions.",
      "priority": 3,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Workflow steps, ordering, consensus policies, and GhostProtocol config links are database-driven - ZERO hardcoded pipeline configurations",
        "Context at lib/swarmshield/workflows.ex",
        "Workflow CRUD: list_workflows/1 (by workspace_id, preload steps + ghost_protocol_config), get_workflow!/1 (preload steps with agent_definitions + ghost_protocol_config), create_workflow/1, update_workflow/2, delete_workflow/1, get_enabled_workflow_for_trigger/2 (workspace_id, trigger_type)",
        "WorkflowStep CRUD: list_workflow_steps/1 (by workflow_id, ordered by position), create_workflow_step/1, update_workflow_step/2, delete_workflow_step/1, reorder_workflow_steps/2 (workflow_id, ordered_ids)",
        "ConsensusPolicy CRUD: list_consensus_policies/1 (by workspace_id), get_consensus_policy!/1, create_consensus_policy/1, update_consensus_policy/2, delete_consensus_policy/1",
        "All list functions preload associations including ghost_protocol_config on workflows",
        "Tests for all CRUD + step reordering",
        "Edge case: get_enabled_workflow_for_trigger/2 returns nil when no matching workflow",
        "Edge case: get_enabled_workflow_for_trigger/2 with :all trigger matches any event status",
        "Edge case: reorder_workflow_steps/2 validates all step IDs belong to the workflow",
        "Edge case: reorder_workflow_steps/2 updates positions atomically (Ecto.Multi)",
        "Edge case: delete_workflow/1 cascades to workflow_steps",
        "Edge case: get_workflow!/1 preloads ghost_protocol_config (for GhostProtocol sessions)",
        "Edge case: workflow with ghost_protocol_config_id=nil is non-ephemeral",
        "Edge case: workflow with ghost_protocol_config preloaded includes wipe_strategy and wipe_fields",
        "QUERY QUALITY: get_workflow!/1 uses multi-level preload [workflow_steps: :agent_definition, :ghost_protocol_config] in optimized query",
        "QUERY QUALITY: reorder_workflow_steps/2 uses Ecto.Multi with single UPDATE per step (not N individual Repo.update calls)",
        "QUERY QUALITY: get_enabled_workflow_for_trigger/2 uses indexed WHERE on [:workspace_id, :enabled, :trigger_on]",
        "QUERY QUALITY: No correlated subqueries - use JOINs for step counts and agent definitions",
        "Minimum 15 test cases",
        "SECURITY: Changesets must NEVER cast [:workspace_id] from user input - set server-side",
        "SECURITY: All CRUD on workflows, steps, and consensus policies must create audit_entry records",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-004",
      "title": "Create GhostProtocol context",
      "description": "GhostProtocol context manages GhostProtocolConfig CRUD and wipe operations. This is the data layer for the flagship security feature - agents that do expert work then vanish completely. All configs are database-driven and managed from admin UI.",
      "priority": 4,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: All GhostProtocol configuration is database-driven - ZERO hardcoded wipe strategies or retention policies",
        "Context at lib/swarmshield/ghost_protocol.ex",
        "list_configs/1 (workspace_id) - returns all configs for workspace, preloads workflows using this config",
        "get_config!/1 (config_id) - returns config with preloaded workflows",
        "create_config/1 (attrs) - creates new config with validation",
        "update_config/2 (config, attrs) - updates config with validation",
        "delete_config/1 (config) - deletes config only if no workflows linked",
        "list_active_ephemeral_sessions/1 (workspace_id) - sessions with ghost_protocol_config that are not completed",
        "get_session_with_ghost_config/1 (session_id) - session with workflow.ghost_protocol_config preloaded",
        "PubSub broadcast on config changes: topic 'ghost_protocol:workspace_id'",
        "PubSub broadcast on wipe events: topic 'ghost_protocol:session_id'",
        "All list functions include preloads (no N+1)",
        "Tests for all CRUD operations",
        "Edge case: delete_config/1 with linked workflows returns {:error, :has_linked_workflows}",
        "Edge case: list_active_ephemeral_sessions/1 only returns sessions where workflow has non-null ghost_protocol_config_id",
        "Edge case: list_active_ephemeral_sessions/1 excludes completed/failed/timed_out sessions",
        "Edge case: get_session_with_ghost_config/1 for non-ephemeral session returns session with nil ghost_protocol_config",
        "Edge case: PubSub broadcast includes config_id and action type (created/updated/deleted)",
        "QUERY QUALITY: list_configs/1 uses LEFT JOIN for workflow count (not N+1)",
        "QUERY QUALITY: list_active_ephemeral_sessions/1 uses JOIN through workflow to ghost_protocol_config",
        "QUERY QUALITY: No correlated subqueries in any function",
        "Minimum 15 test cases",
        "SECURITY: All query functions enforce workspace_id - NEVER return cross-workspace configs",
        "SECURITY: All CRUD operations create audit_entry records",
        "SECURITY: PubSub messages must NOT include sensitive config details - only IDs and action type",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-005",
      "title": "Create PromptRenderer module",
      "description": "Pure-function module that renders prompt templates by interpolating variables. Takes a template string with {{variable}} placeholders and a map of values, returns the rendered string.",
      "priority": 5,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Templates loaded from database PromptTemplate records - renderer is a pure function, content comes from DB",
        "Module at lib/swarmshield/deliberation/prompt_renderer.ex",
        "render/2 - (template_string, variables_map) returns {:ok, rendered_string} or {:error, :missing_variables, [names]}",
        "Replaces all {{variable_name}} occurrences with corresponding map values",
        "Returns error if required variables are missing from the map",
        "extract_variables/1 - returns list of variable names from template",
        "validate_template/2 - (template, available_variables) returns :ok or {:error, missing}",
        "Handles edge cases: empty template, no variables, extra variables (ignored)",
        "Pure functions - no side effects",
        "Pattern matching throughout",
        "Tests for rendering, missing variables, edge cases",
        "Edge case: render/2 with empty template returns {:ok, ''}",
        "Edge case: render/2 with no variables in template ignores provided variables",
        "Edge case: render/2 with {{}} (empty variable name) is treated as literal text",
        "Edge case: render/2 with same variable used multiple times replaces all occurrences",
        "Edge case: render/2 with variable value containing {{other}} does NOT recursively expand",
        "Edge case: validate_template/2 reports all missing variables (not just first)",
        "Minimum 10 test cases",
        "SECURITY: render/2 must NEVER use Code.eval_string or EEx.eval_string - only safe String.replace/3",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-006",
      "title": "Create LLM Budget Agent",
      "description": "GenServer that tracks API spending per workspace. Enforces budget limits to prevent runaway costs. Uses ETS for fast lookups.",
      "priority": 6,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Module at lib/swarmshield/llm/budget.ex",
        "GenServer with named process: Swarmshield.LLM.Budget",
        "ETS table :llm_budget for workspace spending tracking",
        "track_usage/3 - (workspace_id, tokens, cost_cents) records usage",
        "check_budget/1 - (workspace_id) returns {:ok, remaining} or {:error, :budget_exceeded}",
        "get_usage/1 - (workspace_id) returns %{total_tokens: N, total_cost_cents: N, period_start: datetime}",
        "reset_usage/1 - (workspace_id) resets counters for new billing period",
        "Default budget limit from workspace settings (configurable, database-driven)",
        "handle_continue wrapped in try/rescue",
        "All ETS reads rescue ArgumentError",
        "Added to application supervision tree",
        "Tests for tracking, budget check, exceeded budget, reset",
        "Edge case: track_usage/3 with 0 tokens and 0 cost is valid",
        "Edge case: check_budget/1 for workspace with no limit returns {:ok, :unlimited}",
        "Edge case: concurrent track_usage/3 calls are atomic (ETS update_counter)",
        "Edge case: ETS table destroyed - all reads return safe defaults",
        "Minimum 8 test cases",
        "SECURITY: track_usage/3 must validate tokens and cost_cents are non-negative",
        "SECURITY: Budget limit exceeded events must create audit_entry records",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-007",
      "title": "Create LLM Client module",
      "description": "HTTP client for calling Claude Opus 4.6 API via ReqLLM. Includes retries, timeouts, token counting, and cost tracking. All LLM calls go through this module.",
      "priority": 7,
      "passes": true,
      "dependsOn": [
        "DELIB-006"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Module at lib/swarmshield/llm/client.ex",
        "chat/2 - (messages, opts) calls Anthropic API via ReqLLM, returns {:ok, response} or {:error, reason}",
        "Options: model (default claude-opus-4-6), temperature, max_tokens, system_prompt",
        "Retry logic: 3 retries with exponential backoff for 429/500/502/503",
        "Timeout: configurable, default 60 seconds",
        "Extracts token usage from response: input_tokens, output_tokens",
        "Calculates cost in cents based on model pricing",
        "Calls Budget.track_usage/3 after each successful call",
        "Checks Budget.check_budget/1 BEFORE making call",
        "API key from runtime config (Application.get_env), never hardcoded",
        "Tests with mocked HTTP responses (success, rate limit, error)",
        "Edge case: API key missing from config returns {:error, :api_key_not_configured}",
        "Edge case: budget exceeded before call returns {:error, :budget_exceeded}",
        "Edge case: 429 rate limit response triggers retry with exponential backoff",
        "Edge case: 400/401/403 responses do NOT trigger retry (client errors not retryable)",
        "Edge case: timeout after configured seconds returns {:error, :timeout}",
        "Edge case: cost calculation uses correct per-model pricing from config (not hardcoded)",
        "Minimum 10 test cases (using mocked HTTP)",
        "SECURITY: LLM prompt injection prevention - use Anthropic structured message format",
        "SECURITY: SSRF prevention - HTTP client ONLY calls configured Anthropic API endpoint",
        "SECURITY: LLM response parsing must handle malformed JSON safely - try/rescue on Jason.decode",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-008",
      "title": "Create Deliberation Session GenServer with DynamicSupervisor",
      "description": "GenServer managing the lifecycle of a single deliberation session. Started under DynamicSupervisor, orchestrates analysis -> deliberation -> voting -> verdict -> GhostProtocol wipe phases. For ephemeral workflows (ghost_protocol_config_id present), uses restart: :temporary so BEAM GC cleans process memory after termination.",
      "priority": 8,
      "passes": true,
      "dependsOn": [
        "DELIB-001",
        "DELIB-002",
        "DELIB-003",
        "DELIB-004",
        "DELIB-005",
        "DELIB-006",
        "DELIB-007"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Module at lib/swarmshield/deliberation/session.ex",
        "GenServer started via DynamicSupervisor: Swarmshield.Deliberation.SessionSupervisor",
        "DynamicSupervisor added to application supervision tree",
        "start_session/2 - (event, workflow) starts a new session GenServer",
        "For ephemeral workflows (ghost_protocol_config_id present): use restart: :temporary so BEAM GC cleans process memory",
        "Session lifecycle: :pending -> :analyzing -> :deliberating -> :voting -> :completed -> (if ephemeral) :wiping",
        "State tracks: session_id, event, workflow, ghost_protocol_config, agents, messages, current_phase",
        "If workflow has ghost_protocol_config, compute expires_at from max_session_duration_seconds and store on session",
        "If workflow has ghost_protocol_config, compute input_content_hash as SHA-256 of event content and store on session",
        "handle_continue(:start_analysis) kicks off the pipeline",
        "Timeout handling: session-level timeout from workflow config OR ghost_protocol_config max_session_duration_seconds",
        "Error handling: captures errors, updates session status to :failed",
        "PubSub broadcasts on phase transitions: 'deliberation:session_id' and 'ghost_protocol:session_id' for ephemeral sessions",
        "Audit entry created on session start and completion",
        "Tests for session lifecycle, timeout, error recovery, ephemeral vs non-ephemeral",
        "Edge case: start_session/2 with invalid workflow returns {:error, reason}",
        "Edge case: session timeout triggers :timed_out status and GenServer shutdown",
        "Edge case: duplicate start_session/2 for same event returns existing session (idempotent)",
        "Edge case: ephemeral session sets expires_at on creation",
        "Edge case: ephemeral session computes input_content_hash via :crypto.hash(:sha256, content)",
        "Edge case: non-ephemeral session has nil expires_at and nil input_content_hash",
        "Minimum 12 test cases",
        "SECURITY: start_session/2 must verify event and workflow belong to same workspace",
        "SECURITY: Authorization check - verify caller has deliberations:trigger permission",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-009",
      "title": "Implement analysis phase (parallel Opus 4.6 agents)",
      "description": "Analysis phase: spawn parallel Task.Supervisor tasks for each agent in the workflow. Each agent analyzes the flagged event using its configured prompt and returns an initial assessment.",
      "priority": 9,
      "passes": true,
      "dependsOn": [
        "DELIB-008"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Analysis agents, prompts, and model config loaded from database - ZERO hardcoded analysis behavior",
        "Add analysis phase to Deliberation.Session GenServer",
        "Uses Task.Supervisor (Swarmshield.TaskSupervisor) for parallel agent tasks - NOT Task.async",
        "Task.Supervisor added to application supervision tree",
        "For each workflow step: create AgentInstance, render prompt, call LLM.Client",
        "Extract values from state BEFORE creating tasks (no process state copying)",
        "Collects results with Task.yield_many/2 with timeout",
        "Updates AgentInstance with initial_assessment, vote, confidence",
        "Creates DeliberationMessage (type: :analysis) for each agent's output",
        "Handles partial failures: if some agents timeout, proceed with available results",
        "PubSub broadcast: {:analysis_complete, session_id, results}",
        "Tests for parallel execution, partial failure, timeout handling",
        "Edge case: workflow with 0 steps completes analysis immediately",
        "Edge case: single agent failure doesn't prevent other agents from completing",
        "Edge case: all agents timeout - session marked as :failed",
        "Edge case: agent values extracted BEFORE spawning tasks (verified no socket/state copying)",
        "Edge case: LLM response parsing handles malformed JSON gracefully",
        "Minimum 8 test cases",
        "SECURITY: LLM prompt injection prevention - system prompt in system param, event data in user role",
        "SECURITY: All agent definitions verified to belong to same workspace as event",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-010",
      "title": "Implement deliberation phase (cross-agent debate)",
      "description": "Deliberation phase: agents review each other's analyses and engage in structured debate. Each agent can respond to others' assessments with arguments and counter-arguments.",
      "priority": 10,
      "passes": true,
      "dependsOn": [
        "DELIB-009"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Add deliberation phase to Deliberation.Session GenServer",
        "Configurable number of deliberation rounds (default 2, from workflow config)",
        "Each round: compile all previous messages, send to each agent for review",
        "Agents produce :argument or :counter_argument messages",
        "Each agent sees all other agents' analyses and arguments",
        "Prompt includes: original event, all previous messages, instruction to debate",
        "Creates DeliberationMessage for each agent response per round",
        "Agents may update their vote/confidence after deliberation",
        "Extract values from state BEFORE creating tasks",
        "PubSub broadcast: {:deliberation_round_complete, session_id, round, messages}",
        "Tests for multi-round deliberation, vote changes",
        "Edge case: 0 deliberation rounds configured skips deliberation phase entirely",
        "Edge case: agent that timed out in analysis is excluded from deliberation",
        "Edge case: agent changes vote after seeing other arguments",
        "Edge case: deliberation prompt includes ALL previous messages (not just last round)",
        "Minimum 8 test cases",
        "SECURITY: Clearly demarcate system instructions vs user-supplied content in prompts",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-011",
      "title": "Create Consensus module (majority/supermajority/weighted)",
      "description": "Pure-function module implementing voting strategies for reaching verdicts. Supports majority, supermajority, unanimous, and weighted voting.",
      "priority": 11,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Voting strategy, threshold, and weights loaded from database ConsensusPolicy - ZERO hardcoded consensus parameters",
        "Module at lib/swarmshield/deliberation/consensus.ex",
        "evaluate/2 - (votes, consensus_policy) returns {:consensus, decision, details} or {:no_consensus, details}",
        "Majority strategy: >50% of votes agree",
        "Supermajority strategy: >threshold (e.g., 67%) agree",
        "Unanimous strategy: all votes must agree",
        "Weighted strategy: votes weighted by agent role weights from policy",
        "vote_breakdown/1 - returns %{allow: N, flag: N, block: N}",
        "confidence_score/1 - returns average confidence across all voters",
        "dissenting_opinions/2 - returns list of agents who disagreed with majority",
        "Pure functions - no side effects",
        "Pattern matching for strategy dispatch",
        "Tests for each strategy, edge cases (tie, single voter, all abstain)",
        "Edge case: single voter always reaches consensus",
        "Edge case: tie vote (50/50) does NOT reach majority consensus",
        "Edge case: 2 out of 3 voters agree reaches majority (>50%)",
        "Edge case: 2 out of 3 voters agree does NOT reach supermajority at 0.67 threshold",
        "Edge case: unanimous with 1 dissenter returns :no_consensus",
        "Edge case: weighted voting with 0-weight agent effectively excludes that agent",
        "Edge case: all agents abstain (nil vote) returns :no_consensus",
        "Minimum 15 test cases",
        "SECURITY: Vote values validated against explicit allowlist [:allow, :flag, :block, :abstain]",
        "SECURITY: Weighted strategy validates weights are non-negative numbers",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-012",
      "title": "Implement verdict phase (consensus + persist + audit)",
      "description": "Verdict phase: collect final votes from all agents, apply consensus policy, create Verdict record, update session status, create audit entry. After verdict, trigger GhostProtocol wipe if session is ephemeral.",
      "priority": 12,
      "passes": true,
      "dependsOn": [
        "DELIB-010",
        "DELIB-011"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Verdict decision thresholds from database ConsensusPolicy - action mapping from database rules",
        "Add verdict phase to Deliberation.Session GenServer",
        "Collects final votes from all AgentInstances",
        "Calls Consensus.evaluate/2 with votes and session's consensus_policy",
        "Creates Verdict record with: decision, confidence, reasoning, vote_breakdown, dissenting_opinions",
        "Updates AnalysisSession status to :completed, sets completed_at, total_tokens_used, total_cost_cents",
        "Updates original AgentEvent status based on verdict decision",
        "Creates AuditEntry for verdict",
        "PubSub broadcast: {:verdict_reached, session_id, verdict}",
        "If no consensus: verdict decision defaults to :escalate",
        "AFTER verdict: if session is ephemeral (workflow has ghost_protocol_config), trigger wipe engine",
        "For non-ephemeral sessions: GenServer stops after verdict (normal shutdown)",
        "For ephemeral sessions: GenServer transitions to :wiping phase, then stops after wipe completes",
        "Tests for consensus reached, no consensus, verdict persistence, ephemeral vs non-ephemeral post-verdict",
        "Edge case: no consensus reached - verdict decision is :escalate",
        "Edge case: verdict with :block decision updates original event to :blocked",
        "Edge case: total_tokens_used sums all agent_instances tokens",
        "Edge case: ephemeral session triggers wipe after verdict",
        "Edge case: non-ephemeral session skips wipe entirely",
        "Edge case: GenServer sends :normal shutdown after verdict/wipe",
        "Minimum 10 test cases",
        "SECURITY: Verdict decision validated against explicit allowlist [:allow, :flag, :block, :escalate]",
        "SECURITY: Verdict creation must create audit_entry record",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-013",
      "title": "Implement GhostProtocol wipe engine",
      "description": "Post-verdict wipe engine that reads ghost_protocol_config from the workflow's linked config, nulls specified fields, optionally crypto-shreds data, terminates all agent GenServer instances, and records the wipe in audit. Only verdict + audit survive. This is the core of the GhostProtocol feature.",
      "priority": 13,
      "passes": true,
      "dependsOn": [
        "DELIB-012",
        "DELIB-004"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Module at lib/swarmshield/ghost_protocol/wipe_engine.ex",
        "execute_wipe/1 (session_id) - main entry point after verdict, reads ghost_protocol_config from workflow",
        "Reads config's wipe_fields array to determine which fields to null",
        "For each wipe_field: NULL the corresponding column on analysis_session, agent_instances, and deliberation_messages",
        "If crypto_shred is true: overwrite target fields with :crypto.strong_rand_bytes(byte_size(original)) BEFORE setting to NULL",
        "Keeps input_content_hash (SHA-256) on analysis_session for audit linking (NEVER wiped)",
        "Keeps verdict record intact (retain_verdict: true enforced)",
        "Keeps audit_entry records intact (retain_audit: true enforced)",
        "Terminates all agent GenServer instances via DynamicSupervisor.terminate_child",
        "Records terminated_at timestamp on all agent_instances",
        "Creates audit_entry for every wipe action with: session_id, fields_wiped, crypto_shred_used, agents_terminated",
        "PubSub broadcast 'ghost_protocol:session_id' with {:wipe_started, session_id} and {:wipe_completed, session_id}",
        "PubSub broadcast 'ghost_protocol:workspace_id' for dashboard updates",
        "If wipe_strategy is :immediate - execute wipe synchronously after verdict",
        "If wipe_strategy is :delayed - schedule wipe via Process.send_after(self(), {:execute_delayed_wipe, session_id}, delay_ms)",
        "If wipe_strategy is :scheduled - store scheduled wipe time, execute when timer fires",
        "Wipe is idempotent - calling execute_wipe/1 on already-wiped session is a no-op",
        "Tests for all wipe strategies and behaviors",
        "Test: verify specified fields are NULL post-wipe, unspecified fields intact",
        "Test: verify verdict survives wipe (all verdict fields present after wipe)",
        "Test: verify crypto_shred overwrites with random bytes before null (check DB update includes overwrite step)",
        "Test: verify non-ephemeral workflows (no ghost_protocol_config) skip wipe entirely",
        "Test: verify input_content_hash preserved after wipe",
        "Test: verify terminated_at set on all agent_instances",
        "Test: verify audit_entry created with wipe details",
        "Test: verify delayed wipe fires after configured delay",
        "Test: verify idempotent - second wipe call on same session is no-op",
        "Minimum 12 test cases",
        "SECURITY: Wipe fields validated against allowlist before executing database updates",
        "SECURITY: crypto_shred must use :crypto.strong_rand_bytes - not pseudo-random",
        "SECURITY: Wipe audit entry must NOT include the wiped content itself",
        "SECURITY: After wipe, verify no process holds references to wiped data (GenServer state cleared)",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "DELIB-014",
      "title": "Implement GhostProtocol expiry enforcement (auto-terminate)",
      "description": "Session GenServer monitors expires_at and force-terminates sessions that exceed max_session_duration_seconds. Partial verdicts recorded if any agents completed. Enforces the auto_terminate_on_expiry flag from ghost_protocol_config.",
      "priority": 14,
      "passes": true,
      "dependsOn": [
        "DELIB-013"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Session GenServer schedules expiry check via Process.send_after based on expires_at",
        "handle_info(:check_expiry) compares DateTime.utc_now() to expires_at",
        "If session exceeds max_session_duration_seconds AND auto_terminate_on_expiry is true: force-terminate",
        "Force-terminate flow: update session status to :timed_out, record partial verdict if any agents completed analysis, execute GhostProtocol wipe, stop GenServer",
        "Partial verdict: if some agents completed, create verdict with available votes + {:partial, reason}",
        "If auto_terminate_on_expiry is false: log warning but do NOT terminate (allow natural completion)",
        "Creates audit_entry for forced termination with: session_id, reason 'max_session_duration_exceeded', partial_verdict flag",
        "PubSub broadcast: {:session_expired, session_id} on ghost_protocol:session_id and ghost_protocol:workspace_id",
        "Non-ephemeral sessions (no ghost_protocol_config) do not have expiry enforcement",
        "Tests for expiry enforcement",
        "Test: verify expired sessions are force-terminated when auto_terminate_on_expiry=true",
        "Test: verify non-expired sessions complete normally",
        "Test: verify partial verdict created when some agents completed before timeout",
        "Test: verify auto_terminate_on_expiry=false does NOT terminate session",
        "Test: verify non-ephemeral sessions have no expiry timer",
        "Test: verify wipe engine called after forced termination",
        "Test: verify audit_entry created for forced termination",
        "Test: verify PubSub broadcast on expiry",
        "Minimum 8 test cases",
        "SECURITY: Expiry timer must be set server-side from database config - NEVER from client input",
        "SECURITY: Force-terminated sessions must still execute wipe (no data leaks on timeout)",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    }
  ]
}

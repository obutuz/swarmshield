{
  "branchName": "ralph/phase-3-policy",
  "description": "ETS-cached policy engine for sub-millisecond rule evaluation. Evaluates agent events against configurable rules with rate limiting, pattern matching, blocklists, and payload size checks.",
  "phase": 3,
  "phaseName": "Policy Engine",
  "crossPhaseLinks": {
    "phase_1_auth_foundation": "Workspace scoping for all policy operations.",
    "phase_2_core_schemas": "Uses PolicyRule, DetectionRule, PolicyViolation, AgentEvent schemas.",
    "phase_4_api_gateway": "EventController calls PolicyEngine.evaluate/2 on every incoming event.",
    "phase_5_deliberation_engine": "Flagged events from PolicyEngine trigger deliberation sessions.",
    "phase_6_dashboard_liveviews": "Dashboard shows policy evaluation stats and violation counts.",
    "phase_7_admin_liveviews": "Admin UI manages policy rules and detection rules with ETS cache refresh."
  },
  "securityRules": {
    "workspace_scoping": "All context query functions enforce workspace_id as mandatory parameter. NEVER return cross-workspace data.",
    "sql_injection": "All queries use Ecto parameterized queries with ^ pin. NEVER string interpolation in fragment() or raw SQL.",
    "ets_safety": "ETS tables use :protected access (GenServer-mediated writes). Cache refresh debounced to prevent thundering herd.",
    "redos_prevention": "Regex execution uses timeout mechanism. Pre-compiled regex validated on cache load. Max pattern length enforced.",
    "input_validation": "All filter parameters validated via explicit allowlists. Config map values have upper bounds to prevent DoS via misconfiguration.",
    "audit_trail": "All policy rule and detection rule CRUD operations create audit_entry records.",
    "information_leakage": "Evaluation results NEVER include raw rule configs or detection patterns in API responses. Only rule names and match indicators."
  },
  "userStories": [
    {
      "id": "POLICY-001",
      "title": "Create Gateway context",
      "description": "Gateway context manages RegisteredAgent and AgentEvent CRUD operations. All functions include proper preloads. This is the ingestion layer.",
      "priority": 1,
      "passes": true,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Context at lib/swarmshield/gateway.ex",
        "RegisteredAgent CRUD: list_registered_agents/1 (by workspace_id, preload events count), get_registered_agent!/1, get_registered_agent_by_api_key/1 (hash lookup), create_registered_agent/1, update_registered_agent/2, deactivate_registered_agent/1",
        "AgentEvent CRUD: list_agent_events/1 (by workspace_id, filterable by agent/type/status/date, paginated), get_agent_event!/1 (with preloads), create_agent_event/1, update_agent_event_status/2",
        "All list functions support pagination via offset/limit",
        "All list functions preload associations (no N+1)",
        "Pattern matching for all function heads",
        "Tests for all CRUD operations with edge cases",
        "Edge case: list_registered_agents/1 with empty workspace returns empty list",
        "Edge case: get_registered_agent_by_api_key/1 returns nil for non-existent hash",
        "Edge case: deactivate_registered_agent/1 sets status to :suspended and updates last_seen_at",
        "Edge case: list_agent_events/1 filters compose correctly (agent AND type AND status)",
        "Edge case: create_agent_event/1 increments registered_agent.event_count atomically",
        "Edge case: pagination returns correct total_count alongside results",
        "QUERY QUALITY: list_registered_agents/1 uses LEFT JOIN with aggregate for event count (not N+1 Enum.count)",
        "QUERY QUALITY: list_agent_events/1 uses JOINs for preloads, database-level WHERE for filters, database LIMIT/OFFSET for pagination",
        "QUERY QUALITY: No correlated subqueries - event counts use JOIN + GROUP BY, not per-agent subquery",
        "QUERY QUALITY: All list functions return {results, total_count} tuple with COUNT query using same WHERE conditions",
        "QUERY QUALITY: create_agent_event/1 increments event_count via Repo.update_all(inc: [event_count: 1]) - atomic, no read-modify-write race",
        "QUERY QUALITY: Combined filters (agent AND type AND status AND date) compose as single query with AND conditions, not sequential filtering",
        "Minimum 20 test cases covering all CRUD + edge cases",
        "SECURITY: All query functions must enforce workspace_id as mandatory parameter - NEVER return cross-workspace data",
        "SECURITY: update_agent_event_status/2 must validate status transitions (pending -> allowed/flagged/blocked only) - prevent invalid state transitions",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-002",
      "title": "Create Policies context",
      "description": "Policies context manages PolicyRule, DetectionRule, and PolicyViolation CRUD. Broadcasts PubSub events on rule changes for ETS cache invalidation.",
      "priority": 2,
      "passes": false,
      "dependsOn": [],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: All policy rules and detection rules are database records managed via context - ZERO hardcoded rules in engine code",
        "Context at lib/swarmshield/policies.ex",
        "PolicyRule CRUD: list_policy_rules/1 (by workspace_id, filterable), get_policy_rule!/1, create_policy_rule/1, update_policy_rule/2, delete_policy_rule/1, list_enabled_policy_rules/1",
        "DetectionRule CRUD: list_detection_rules/1 (by workspace_id), get_detection_rule!/1, create_detection_rule/1, update_detection_rule/2, delete_detection_rule/1",
        "PolicyViolation CRUD: list_policy_violations/1 (by workspace_id, filterable, paginated), get_policy_violation!/1, create_policy_violation/1, resolve_policy_violation/3 (violation, user, notes)",
        "PubSub broadcast on policy_rule create/update/delete: topic 'policy_rules:workspace_id'",
        "PubSub broadcast on detection_rule changes: topic 'detection_rules:workspace_id'",
        "All list functions preload associations",
        "Tests for all CRUD + PubSub broadcasts",
        "Edge case: resolve_policy_violation/3 sets resolved_at to now and resolved_by_id",
        "Edge case: resolve_policy_violation/3 on already-resolved violation returns error",
        "Edge case: delete_policy_rule/1 that has linked violations returns error (referential integrity)",
        "Edge case: PubSub broadcast includes workspace_id in topic for targeted cache refresh",
        "Edge case: list_enabled_policy_rules/1 returns only enabled=true rules ordered by priority DESC",
        "QUERY QUALITY: list_policy_violations/1 uses JOINs for event and rule preloads in single query (not N+1)",
        "QUERY QUALITY: list_policy_violations/1 uses database-level pagination with {results, total_count} tuple",
        "QUERY QUALITY: All list functions filter at database level (WHERE clauses), never post-load Enum.filter",
        "QUERY QUALITY: No correlated subqueries in any context function",
        "QUERY QUALITY: resolve_policy_violation/3 uses atomic update (not read-modify-write)",
        "Minimum 20 test cases",
        "SECURITY: All query functions must enforce workspace_id as mandatory parameter - NEVER allow cross-workspace data leakage",
        "SECURITY: All CRUD operations must create audit_entry records (policy changes are security-critical)",
        "SECURITY: PubSub broadcast messages must NOT include sensitive rule config data - include only IDs and action type",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-003",
      "title": "Create PolicyCache GenServer with ETS",
      "description": "PolicyCache is a GenServer that maintains ETS tables for sub-millisecond policy rule lookups. Loads rules on startup, refreshes on PubSub events. MUST follow ETS safety patterns.",
      "priority": 3,
      "passes": false,
      "dependsOn": [
        "POLICY-002"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: ETS cache loads ALL data from database - cache is a performance layer, not a source of truth. ZERO hardcoded rules in cache",
        "Module at lib/swarmshield/policies/policy_cache.ex",
        "GenServer with named process: Swarmshield.Policies.PolicyCache",
        "Creates ETS table :policy_rules_cache (set, public, read_concurrency: true)",
        "Creates ETS table :detection_rules_cache (set, public, read_concurrency: true)",
        "handle_continue(:load_cache, state) wrapped in try/rescue - logs warning on failure, does NOT crash",
        "Subscribes to PubSub topics: 'policy_rules:*' and 'detection_rules:*'",
        "handle_info for PubSub messages triggers selective cache refresh",
        "Public API: get_rules/1 (workspace_id), get_detection_rules/1 (workspace_id), refresh/1 (workspace_id), refresh_all/0",
        "All public ETS reads rescue ArgumentError and return safe defaults (empty list)",
        "Added to application supervision tree",
        "Tests for cache load, refresh, PubSub-triggered updates, crash recovery",
        "Edge case: get_rules/1 for workspace with no rules returns empty list",
        "Edge case: ETS table destroyed externally - reads return empty list (not crash)",
        "Edge case: database unreachable during handle_continue - logs warning, starts with empty cache",
        "Edge case: PubSub message for different workspace only refreshes that workspace's cache entries",
        "Edge case: concurrent refresh/0 calls don't cause race conditions",
        "Edge case: GenServer restart recovers ETS tables via init/1",
        "Minimum 12 test cases",
        "SECURITY: Cache refresh must be debounced - bulk rule updates should not cause thundering herd on database",
        "SECURITY: ETS table names must be module-internal atoms, never derived from user input",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-004",
      "title": "Create PolicyEngine pure-function module",
      "description": "PolicyEngine is a pure-function module (no GenServer, no side effects) that evaluates an agent event against cached policy rules. Returns an evaluation result with matched rules and recommended action.",
      "priority": 4,
      "passes": false,
      "dependsOn": [
        "POLICY-003"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "Module at lib/swarmshield/policies/policy_engine.ex",
        "evaluate/2 - (agent_event, workspace_id) returns {:allow | :flag | :block, [matched_rules], details_map}",
        "Reads rules from PolicyCache ETS (not from database)",
        "Evaluates rules in priority order (highest priority first)",
        "Short-circuits on first :block rule match",
        "Collects all :flag matches",
        ":allow is default when no rules match",
        "Pure functions - no side effects, no database writes",
        "Pattern matching throughout",
        "Tests with various rule combinations and priorities",
        "Edge case: evaluate/2 with no cached rules returns {:allow, [], details}",
        "Edge case: evaluate/2 with all disabled rules returns {:allow, [], details}",
        "Edge case: evaluate/2 returns duration_us in details map (for telemetry)",
        "Edge case: evaluate/2 with event missing optional fields (nil source_ip) doesn't crash",
        "Minimum 10 test cases",
        "SECURITY: evaluate/2 must have a total evaluation timeout to prevent slow rules from blocking API requests indefinitely",
        "SECURITY: Evaluation details must NOT include raw rule config or detection patterns in returned result - only rule names and match indicators",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-005",
      "title": "Rate limit rule evaluation",
      "description": "Implements rate limiting evaluation using ETS-based sliding window counters. Tracks event counts per agent within configurable time windows.",
      "priority": 5,
      "passes": false,
      "dependsOn": [
        "POLICY-004"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Rate limit thresholds (max_events, window_seconds) come from database rule config - ZERO hardcoded rate limits",
        "Module at lib/swarmshield/policies/rules/rate_limit.ex",
        "evaluate/2 - (event, rule) checks if agent exceeds rate limit",
        "Uses ETS table :rate_limit_counters for sliding window tracking",
        "Rule config format: %{max_events: N, window_seconds: N, per: 'agent' | 'workspace'}",
        "Sliding window implementation: stores {key, count, window_start} in ETS",
        "Atomic increment via :ets.update_counter/3",
        "Window expiry handled on read (lazy cleanup)",
        "Returns {:ok, :within_limit} or {:violation, details}",
        "All ETS reads rescue ArgumentError",
        "Tests for within limit, exceeded, window expiry, multiple agents",
        "Edge case: first event for agent always passes rate limit",
        "Edge case: rate limit counter resets after window expires",
        "Edge case: concurrent increments are atomic (no lost updates)",
        "Edge case: per-workspace rate limit counts all agents together",
        "Edge case: per-agent rate limit counts each agent separately",
        "Minimum 8 test cases",
        "SECURITY: Rate limit counters in ETS must include TTL-based cleanup to prevent unbounded memory growth",
        "SECURITY: Rate limit counter key must include workspace_id to prevent cross-workspace counter pollution",
        "SECURITY: Config values (window_seconds, max_events) must have upper bound validation to prevent DoS via misconfiguration",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-006",
      "title": "Pattern match rule evaluation",
      "description": "Implements pattern matching evaluation using cached detection rules. Checks event content against regex patterns and keyword lists.",
      "priority": 6,
      "passes": false,
      "dependsOn": [
        "POLICY-004"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: All regex patterns and keywords loaded from database DetectionRule records - ZERO hardcoded patterns",
        "Module at lib/swarmshield/policies/rules/pattern_match.ex",
        "evaluate/2 - (event, rule) checks event content against detection patterns",
        "Loads detection rules from PolicyCache ETS",
        "Regex matching: pre-compiled regex from cache, match against event.content",
        "Keyword matching: case-insensitive keyword search in event.content",
        "Returns {:ok, :no_match} or {:violation, %{matched_patterns: [...], detection_rule_ids: [...]}}",
        "Handles invalid/corrupt regex gracefully (log warning, skip rule)",
        "Pattern matching for detection_type dispatch (:regex vs :keyword)",
        "Tests for regex match, keyword match, no match, invalid regex",
        "Edge case: regex with timeout protection (Regex.run with timeout option)",
        "Edge case: empty content string returns no match",
        "Edge case: content with unicode characters matches correctly",
        "Edge case: multiple detection rules - all matches reported (not just first)",
        "Edge case: disabled detection rules are skipped",
        "Minimum 10 test cases",
        "SECURITY: Regex execution must use explicit timeout (Task with 100ms timeout) to prevent ReDoS",
        "SECURITY: Pattern match results must NOT include matched content snippets in evaluation response - prevents information leakage to API caller",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-007",
      "title": "Blocklist/allowlist rule evaluation",
      "description": "Implements blocklist and allowlist evaluation. Checks agent names, IPs, or content against configured lists.",
      "priority": 7,
      "passes": false,
      "dependsOn": [
        "POLICY-004"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Blocklist/allowlist values stored in database rule config - ZERO hardcoded block/allow lists",
        "Module at lib/swarmshield/policies/rules/list_match.ex",
        "evaluate/2 - (event, rule) checks event attributes against configured lists",
        "Rule config format: %{list_type: 'blocklist' | 'allowlist', field: 'agent_name' | 'source_ip' | 'content', values: [...]}",
        "Blocklist: returns :violation if field value is in the list",
        "Allowlist: returns :violation if field value is NOT in the list",
        "Case-insensitive matching for string values",
        "Returns {:ok, :passed} or {:violation, details}",
        "Pattern matching for list_type dispatch",
        "Tests for blocklist hit/miss, allowlist hit/miss, case insensitivity",
        "Edge case: empty values list for blocklist means nothing blocked",
        "Edge case: empty values list for allowlist means everything blocked",
        "Edge case: field value not present in event (nil) - blocklist passes, allowlist fails",
        "Edge case: values with leading/trailing whitespace trimmed before comparison",
        "Minimum 8 test cases",
        "SECURITY: Field access for matching must use strict whitelist [:agent_name, :source_ip, :content, :event_type] - NEVER dynamically access arbitrary struct fields from config string",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-008",
      "title": "Payload size rule evaluation",
      "description": "Implements payload size checking. Validates that event content and payload don't exceed configured size limits.",
      "priority": 8,
      "passes": false,
      "dependsOn": [
        "POLICY-004"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Size limits come from database rule config - ZERO hardcoded byte limits",
        "Module at lib/swarmshield/policies/rules/payload_size.ex",
        "evaluate/2 - (event, rule) checks event content and payload sizes",
        "Rule config format: %{max_content_bytes: N, max_payload_bytes: N}",
        "Checks byte_size of event.content against max_content_bytes",
        "Checks byte_size of Jason.encode!(event.payload) against max_payload_bytes",
        "Returns {:ok, :within_limit} or {:violation, %{content_bytes: N, payload_bytes: N, limits: %{...}}}",
        "Handles nil content/payload gracefully",
        "Tests for within limit, exceeded, nil values",
        "Edge case: nil content treated as 0 bytes",
        "Edge case: nil payload treated as 0 bytes",
        "Edge case: empty string content is 0 bytes",
        "Edge case: unicode content byte_size differs from String.length",
        "Edge case: only max_content_bytes set (max_payload_bytes not checked)",
        "Minimum 6 test cases",
        "SECURITY: Jason.encode!(event.payload) must be wrapped in try/rescue to prevent crash on non-serializable data",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-009",
      "title": "Composite rule evaluation in PolicyEngine",
      "description": "Wire all individual rule evaluators into the PolicyEngine. The engine dispatches to the correct evaluator based on rule_type and combines results.",
      "priority": 9,
      "passes": false,
      "dependsOn": [
        "POLICY-005",
        "POLICY-006",
        "POLICY-007",
        "POLICY-008"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Rule evaluation dispatches based on database-stored rule_type - ZERO hardcoded evaluation logic per type",
        "Update lib/swarmshield/policies/policy_engine.ex",
        "evaluate/2 dispatches to correct rule module based on rule_type via pattern matching",
        "Rate limit rules -> RateLimit.evaluate/2",
        "Pattern match rules -> PatternMatch.evaluate/2",
        "Blocklist/allowlist rules -> ListMatch.evaluate/2",
        "Payload size rules -> PayloadSize.evaluate/2",
        "Results aggregated: any :block = final :block, any :flag = final :flag, otherwise :allow",
        "Returns comprehensive evaluation result: {action, matched_rules, %{evaluated_count: N, block_count: N, flag_count: N, duration_us: N}}",
        "Telemetry event emitted: [:swarmshield, :policy_engine, :evaluate]",
        "Tests with mixed rule types, priority ordering, short-circuit on block",
        "Edge case: unknown rule_type is logged and skipped (not crash)",
        "Edge case: rules with applies_to_event_types filter only match specified event types",
        "Edge case: rules with applies_to_agent_types filter only match specified agent types",
        "Edge case: empty applies_to arrays means rule applies to all types",
        "Edge case: multiple :flag matches all collected in matched_rules list",
        "Edge case: first :block match short-circuits (remaining rules not evaluated)",
        "Minimum 15 test cases",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-011",
      "title": "Create ApiKeyCache GenServer with ETS",
      "description": "ETS-cached API key -> RegisteredAgent lookup for sub-millisecond API authentication. At 20M users, every API request hitting the database for key validation is catastrophic. Caches the SHA256 hash -> {agent_id, workspace_id, status} mapping. PubSub-driven invalidation on agent status changes, suspension, key regeneration.",
      "priority": 11,
      "passes": false,
      "dependsOn": [
        "POLICY-001"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: ETS cache loads data from database - cache is a performance layer, not source of truth",
        "Module at lib/swarmshield/gateway/api_key_cache.ex",
        "GenServer with named process: Swarmshield.Gateway.ApiKeyCache",
        "Creates ETS table :api_key_cache (set, public, read_concurrency: true)",
        "Cache key: api_key_hash (string) -> %{agent_id: binary_id, workspace_id: binary_id, status: atom, agent_name: string}",
        "handle_continue(:load_cache, state) wrapped in try/rescue - logs warning on failure, does NOT crash",
        "Public API: get_agent_by_key_hash/1 (key_hash) - reads from ETS, falls back to database on miss, caches result",
        "Public API: invalidate_agent/1 (agent_id) - removes cache entry for specific agent",
        "Public API: invalidate_key/1 (key_hash) - removes specific key hash entry",
        "Public API: refresh_all/0 - reloads all active agents into cache",
        "Cache miss strategy: on miss, query database, cache result if found (write-through on read)",
        "Negative caching: cache miss for invalid keys stored as :not_found with 60-second TTL to prevent repeated DB lookups for brute-force attacks",
        "Subscribes to PubSub 'agents:status_changed' for immediate invalidation on suspend/revoke",
        "Subscribes to PubSub 'agents:key_regenerated' for immediate invalidation on key rotation",
        "Subscribes to PubSub 'agents:deleted' for immediate removal from cache",
        "All public ETS reads rescue ArgumentError and fall back to database query",
        "Added to application supervision tree (start before Endpoint)",
        "Pattern matching for all function heads",
        "Tests for cache hit, cache miss, invalidation, PubSub-triggered removal, negative caching",
        "Edge case: suspended agent cached but returns {:error, :suspended} on lookup",
        "Edge case: ETS table destroyed - falls back to database, rebuilds entry",
        "Edge case: concurrent lookups for same key don't cause duplicate DB queries (use :ets.insert_new or accept benign race)",
        "Edge case: cache entry for deleted agent removed immediately on PubSub",
        "Edge case: key regeneration invalidates old hash AND caches new hash",
        "Edge case: negative cache entry expires after TTL (60s default), allowing retry",
        "Minimum 12 test cases",
        "SECURITY: Cache entries must NOT contain raw API key - only the hash is used as lookup key",
        "SECURITY: Negative caching prevents brute-force amplification but must expire to allow legitimate key changes",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    },
    {
      "id": "POLICY-010",
      "title": "Seed default policy rules and detection rules",
      "description": "Seed file that creates sensible default policy rules and detection rules for a new workspace. These serve as starting templates that admins can customize.",
      "priority": 10,
      "passes": false,
      "dependsOn": [
        "POLICY-002"
      ],
      "acceptanceCriteria": [
        "MANDATORY: Read progress.txt for existing implementations BEFORE coding - NO DUPLICATES",
        "MANDATORY: Seeds create database records only. Application code reads rules from database/ETS - never from seed file directly",
        "Seed file at priv/repo/seeds/policy_rules.exs",
        "Creates default policy rules: rate_limit (100 events/minute per agent), pattern_match (prompt injection detection), blocklist (example blocked terms), payload_size (1MB content, 5MB payload)",
        "Creates default detection rules: prompt_injection patterns (regex for common injection attempts), PII detection (SSN, email, credit card regex), toxicity keywords, data exfiltration patterns",
        "All rules associated with seed workspace (requires AUTH seed to run first)",
        "Idempotent: uses on_conflict: :nothing",
        "Can run multiple times safely",
        "Included in main seeds.exs after auth seeds",
        "Edge case: running seeds twice doesn't create duplicates",
        "Edge case: all regex patterns in detection rules compile successfully",
        "Edge case: seed policy rules reference seed detection rules correctly",
        "mix format passes",
        "mix credo --strict passes",
        "mix test passes"
      ]
    }
  ]
}